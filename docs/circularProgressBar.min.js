
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var CircularProgressBar = (function () {
  'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  var defaultOptions = {
    percent: 0,
    colorSlice: '#00a1ff',
    colorCircle: '#e6e6e6',
    stroke: 15,
    round: false,
    opacity: 0.1,
    number: false,
    size: 200,
    time: 1000,
    fontSize: '3rem',
    fontWeight: 400,
    fontColor: '#000',
    lineargradient: false
  };

  var CircularProgressBar = function CircularProgressBar(pieName) {
    var _this = this;

    _classCallCheck(this, CircularProgressBar);

    _defineProperty(this, "initial", function (elements) {
      elements.forEach(function (element) {
        var dataPie = JSON.parse(element.getAttribute('data-pie'));

        var options = _objectSpread2(_objectSpread2({}, defaultOptions), dataPie);

        options.center = options.size / 2;
        options.radius = options.stroke ? options.center - options.stroke / 2 : options.center;
        _this.options = options;
        var svg = "\n      <svg \n        width='".concat(options.size, "' \n        height='").concat(options.size, "' viewBox='0 0 ").concat(options.size, " ").concat(options.size, "'>\n          ").concat(_this.setCircle(), "\n          ").concat(_this.setPath(_this.options), "\n          ").concat(_this.setText(), "\n        </svg>");
        element.insertAdjacentHTML('beforeend', svg);

        _this.animateTo(options.percent, options.time, true);
      });
    });

    _defineProperty(this, "setCircle", function () {
      var _this$options = _this.options,
          stroke = _this$options.stroke,
          colorCircle = _this$options.colorCircle,
          center = _this$options.center,
          radius = _this$options.radius;
      return "\n    <circle\n      stroke-width='".concat(stroke, "'\n      fill=none\n      stroke=").concat(colorCircle, "\n      cx='").concat(center, "'\n      cy='").concat(center, "'\n      r='").concat(radius, "' />");
    });

    _defineProperty(this, "setPath", function (options) {
      var index = options.index,
          stroke = options.stroke,
          colorSlice = options.colorSlice;
      return "\n    <path \n      class=\"path-".concat(index, "\"\n      stroke-width=\"").concat(stroke, "\"\n      fill=\"none\"\n      stroke=\"").concat(colorSlice, "\"\n      d=\"").concat(_this.describeArc(0, _this.percent(0), options), "\" />\n    ");
    });

    _defineProperty(this, "setText", function () {
      var _this$options2 = _this.options,
          index = _this$options2.index,
          fontSize = _this$options2.fontSize,
          fontWeight = _this$options2.fontWeight,
          fontColor = _this$options2.fontColor;
      return "\n    <text \n      class=\"text-".concat(index, "\"\n      x=\"50%\"\n      y=\"50%\"\n      font-size=\"").concat(fontSize, "\"\n      font-weight=\"").concat(fontWeight, "\"\n      fill=\"").concat(fontColor, "\"\n      text-anchor=\"middle\"\n      alignment-baseline=\"central\" />\n    ");
    });

    _defineProperty(this, "changeAngle", function (angle) {
      document.querySelector(".path-4").setAttribute('d', _this.describeArc(0, _this.percent(angle)));
    });

    _defineProperty(this, "step", function (angleOffset, endAngle, time, endTime) {
      var now = new Date().valueOf();
      var timeOffset = endTime - now; // console.log(angleOffset, endAngle, time, endTime);

      if (timeOffset <= 0) {
        // this.changeAngle({ ...options, percent });
        _this.changeAngle(endAngle);
      } else {
        // let percent = percent - (angleOffset * timeOffset) / time;
        var angle = endAngle - angleOffset * timeOffset / time; // this.changeAngle({ ...options, percent });

        _this.changeAngle(angle);

        requestAnimationFrame(function () {
          return _this.step(angleOffset, endAngle, time, endTime);
        }); // requestAnimationFrame(() => this.step(options));
      }
    });

    _defineProperty(this, "animateTo", function (angle) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
      var firstInitial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (angle > 360) {
        angle = angle % 360;
      }

      var startTime = new Date().valueOf();
      var endTime = startTime + time;
      var angleOffset = angle - (firstInitial ? 0 : _this.options.percent); // console.log('time: ', time);

      _this.setPercent({
        angle: angle,
        angleOffset: angleOffset,
        time: time
      });

      requestAnimationFrame(function () {
        return _this.step(angleOffset, angle, time, endTime);
      });
    });

    _defineProperty(this, "polarToCartesian", function (centerX, centerY, radius, angleInDegrees) {
      var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
      return {
        x: centerX + radius * Math.cos(angleInRadians),
        y: centerY + radius * Math.sin(angleInRadians)
      };
    });

    _defineProperty(this, "describeArc", function (startAngle, endAngle) {
      var _this$options3 = _this.options,
          center = _this$options3.center,
          radius = _this$options3.radius;

      var start = _this.polarToCartesian(center, center, radius, endAngle);

      var end = _this.polarToCartesian(center, center, radius, startAngle);

      var largeArcFlag = endAngle - startAngle <= 180 ? '0' : '1';
      var d = [// eslint-disable-next-line prettier/prettier
      'M', start.x, start.y, // eslint-disable-next-line prettier/prettier
      'A', radius, radius, 0, largeArcFlag, 0, end.x, end.y].join(' '); // console.log(d);

      return d;
    });

    _defineProperty(this, "percent", function (percent) {
      return percent / 100 * 360 - 0.0001;
    });

    _defineProperty(this, "setPercent", function (_ref) {
      var angle = _ref.angle,
          angleOffset = _ref.angleOffset,
          time = _ref.time;
      var index = 4;
      var per = time / angle;
      console.log(per, angle, angleOffset, time);

      if (angleOffset >= angle) {
        var i = 0;
        var t = setInterval(function () {
          i++; // console.log('up: ', i);

          document.querySelector(".text-".concat(index)).innerHTML = "".concat(i, "%");

          if (i >= angle) {
            clearInterval(t);
          }
        }, per);
      } else {
        var _i = Math.abs(angleOffset);

        var myinterval = setInterval(function () {
          document.querySelector(".text-".concat(index)).innerHTML = "".concat(_i, "%");
          console.log('down: ', _i);

          if (_i === angle) {
            clearInterval(myinterval);
          } else {
            _i--;
          }
        }, per);
      }
    });

    this.pieName = pieName;
    this.pieElements = document.querySelectorAll(".".concat(pieName));
    this.initial(this.pieElements);
  };

  return CircularProgressBar;

}());
//# sourceMappingURL=circularProgressBar.min.js.map


(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var CircularProgressBar = (function () {
  'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  var defaultOptions = {
    colorCircle: false,
    colorSlice: '#00a1ff',
    end: 264,
    fontColor: '#365b74',
    fontSize: '1.6rem',
    fontWeight: 700,
    lineargradient: false,
    number: true,
    opacity: 10,
    round: false,
    size: 200,
    stroke: 10
  };

  var CircularProgressBar = function CircularProgressBar(pieName) {
    var _this = this;

    _classCallCheck(this, CircularProgressBar);

    _defineProperty(this, "initial", function (elements) {
      if ('IntersectionObserver' in window) {
        var config = {
          root: null,
          rootMargin: '0px',
          threshold: 0
        };
        var i = 0;
        var ovserver = new IntersectionObserver(function (entries, observer) {
          entries.forEach(function (entry) {
            if (entry.isIntersecting && entry.intersectionRatio > 0.75) {
              _this.createSvg(entry.target, i);

              observer.unobserve(entry.target);
              i++;
            }
          });
        }, config);
        elements.forEach(function (item) {
          ovserver.observe(item);
        });
      } else {
        for (var _i = 0; _i < elements.length; _i++) {
          _this.createSvg(elements[_i], _i);
        }
      }
    });

    _defineProperty(this, "hexTorgb", function (hex, opacity) {
      return 'rgba(' + // eslint-disable-next-line no-param-reassign
      (hex = hex.replace('#', '')).match(new RegExp('(.{' + hex.length / 3 + '})', 'g')).map(function (el) {
        return parseInt(hex.length % 2 ? el + el : el, 16);
      }).concat(opacity / 100 || 1).join(',') + ')';
    });

    _defineProperty(this, "circularBar", function (svg, target, options) {
      var index = options.index,
          number = options.number,
          stroke = options.stroke,
          round = options.round,
          lineargradient = options.lineargradient,
          colorSlice = options.colorSlice,
          colorCircle = options.colorCircle,
          opacity = options.opacity,
          size = options.size;
      if (number) svg.insertAdjacentHTML('beforeend', _this.percentElement(options));
      var element = document.querySelector(".".concat(_this.pieName, "-circle-").concat(index));
      var objsvg = {
        fill: 'none',
        transform: 'rotate(-90, 50, 50)',
        'stroke-width': stroke,
        'stroke-linecap': round ? 'round' : ''
      };

      _this.setAttr(element, objsvg, false); // animation


      _this.animationTo(_objectSpread2(_objectSpread2({}, options), {}, {
        element: element
      }), true); // set linear gradient


      element.setAttribute('stroke', lineargradient ? "url(#linear-".concat(index, ")") : colorSlice); // box shadow

      var boxShadow = !colorCircle ? "border-radius:50%;box-shadow:inset 0px 0px ".concat(stroke, "px ").concat(stroke, "px ").concat(_this.hexTorgb(colorSlice, opacity)) : '';
      target.setAttribute('style', "".concat(size, "px;height:").concat(size, "px;position:relative;").concat(boxShadow));
    });

    _defineProperty(this, "animationTo", function (options) {
      var initial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var index = options.index,
          percent = options.percent;
      var getElement = document.querySelector(".pie-circle-".concat(index));
      if (!getElement) return;
      var angle = JSON.parse(getElement.getAttribute('data-angel'));
      var previous = JSON.parse(_this.pieElement[index].getAttribute('data-pie'));
      var config = initial ? options : _objectSpread2(_objectSpread2(_objectSpread2({}, previous), defaultOptions), options);
      var element = document.querySelector(".pie-circle-".concat(index));
      var place = document.getElementById("".concat(_this.pieName, "-percent-").concat(index));
      if (percent > 100 || percent < 0 || angle === percent) return;
      var request;
      var i = initial ? 0 : angle;

      var performAnimation = function performAnimation() {
        if (angle >= config.percent) {
          i--;
        } else {
          i++;
        }

        request = requestAnimationFrame(performAnimation);
        element.setAttribute('stroke-dasharray', i * 2.64 + ', 20000');

        if (place && config.number) {
          place.textContent = "".concat(i, "%");
        }

        if (i === percent) {
          element.setAttribute('data-angel', i);
          cancelAnimationFrame(request);
        }
      };

      requestAnimationFrame(performAnimation);
    });

    _defineProperty(this, "percentElement", function (_ref) {
      var index = _ref.index,
          fontSize = _ref.fontSize,
          fontWeight = _ref.fontWeight,
          fontColor = _ref.fontColor;
      var textTemplate = "\n    <text id=\"".concat(_this.pieName, "-percent-").concat(index, "\" x=\"50%\" y=\"50%\" font-size=\"").concat(fontSize, "\" font-weight=\"").concat(fontWeight, "\" fill=\"").concat(fontColor, "\" text-anchor=\"middle\" dominant-baseline=\"central\" />");
      return textTemplate;
    });

    _defineProperty(this, "createSvg", function (element, index) {
      var dataOptions = JSON.parse(element.getAttribute('data-pie'));

      var options = _objectSpread2(_objectSpread2(_objectSpread2({}, defaultOptions), dataOptions), index);

      var svg = document.createElementNS(_this.svg, 'svg');
      var objSvg = {
        width: options.size,
        height: options.size,
        viewBox: '0 0 100 100'
      };

      _this.setAttr(svg, objSvg, false);

      if (options.colorCircle) {
        svg.appendChild(_this.circleSvg(dataOptions, 'bottom'));
      }

      if (options.lineargradient) {
        svg.appendChild(_this.linearGradient(options.index, options));
      }

      svg.appendChild(_this.circleSvg(dataOptions, 'top', true));
      element.appendChild(svg);

      _this.circularBar(svg, element, options);
    });

    _defineProperty(this, "linearGradient", function (index, options) {
      var defs = document.createElementNS(_this.svg, 'defs');
      var linearGradient = document.createElementNS(_this.svg, 'linearGradient');
      linearGradient.id = "linear-".concat(index);
      var countGradient = [].slice.call(options.lineargradient);
      defs.appendChild(linearGradient);
      var number = 0;

      for (var i = 0; i < countGradient.length; i++) {
        var stop = document.createElementNS(_this.svg, 'stop');
        var objStop = {
          offset: "".concat(number, "%"),
          'stop-color': "".concat(countGradient[i])
        };

        _this.setAttr(stop, objStop, false);

        linearGradient.appendChild(stop);
        number += 100 / (countGradient.length - 1);
      }

      return defs;
    });

    _defineProperty(this, "circleSvg", function (options, where) {
      var setAngel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var circleElement = document.createElementNS(_this.svg, 'circle');
      var typeCircle = where === 'top' ? {
        class: "".concat(_this.pieName, "-circle-").concat(options.index)
      } : {
        fill: 'none',
        stroke: options.colorCircle,
        'stroke-width': options.stroke
      };

      var objCircle = _objectSpread2({
        cx: 50,
        cy: 50,
        r: 42,
        'shape-rendering': 'geometricPrecision',
        'data-angle': setAngel ? 0 : ''
      }, typeCircle);

      _this.setAttr(circleElement, objCircle, false);

      return circleElement;
    });

    _defineProperty(this, "setAttr", function (element, object) {
      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      for (var key in object) {
        if (type) {
          element.setAttributeNS(null, key, object[key]);
        } else {
          element.setAttribute(key, object[key]);
        }
      }
    });

    this.pieName = pieName;
    this.pieElement = document.querySelectorAll(".".concat(pieName));
    this.svg = 'http://www.w3.org/2000/svg';
    this.initial(this.pieElement);
  };

  return CircularProgressBar;

}());
//# sourceMappingURL=circularProgressBar.min.js.map
